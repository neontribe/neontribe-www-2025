---
export interface Props {
  action?: string;
  method?: 'get' | 'post';
  title?: string;
  description?: string;
  class?: string;
  formId?: string;
  successMessage?: string;
  errorMessage?: string;
}

const {
  action = '/',
  method = 'post',
  title,
  description,
  class: className = '',
  formId,
  successMessage = 'Thank you! Your message has been sent successfully.',
  errorMessage = 'Sorry, there was an error submitting your form. Please try again.',
} = Astro.props;

const uniqueFormId = formId || `form-${Math.random().toString(36).substring(2, 11)}`;
---

<form 
  id={uniqueFormId}
  action={action} 
  method={method}
  class={`form ${className}`}
  novalidate
  data-formbold-form
  data-form-id={uniqueFormId}
>
  {title && (
    <h2 class="form-title">{title}</h2>
  )}
  {description && (
    <p class="form-description">{description}</p>
  )}
  
  <!-- Success message (hidden by default) -->
  <div 
    class="form-message form-message-success" 
    role="alert" 
    aria-live="polite"
    hidden
  >
    <p>{successMessage}</p>
  </div>
  
  <!-- Error message (hidden by default) -->
  <div 
    class="form-message form-message-error" 
    role="alert" 
    aria-live="assertive"
    hidden
  >
    <p>{errorMessage}</p>
  </div>
  
  <div class="form-fields">
    <slot />
  </div>
</form>

<script is:inline>
(function() {
  function initForm(form) {
    if (!form || form.tagName !== 'FORM') {
      return;
    }

    // Get references to important elements in the form
    const successMessage = form.querySelector('.form-message-success');
    const errorMessage = form.querySelector('.form-message-error');
    const submitButton = form.querySelector('button[type="submit"]');
    
    const originalButtonText = submitButton 
      ? (submitButton.textContent || 'Submit') 
      : 'Submit';

    function getFieldLabel(input) {
      const fieldId = input.id;
      if (!fieldId) {
        return 'This field';
      }
      
      // Try to find the label element that's associated with this input
      const label = form.querySelector(`label[for="${fieldId}"]`);
      
      if (label && label.textContent) {
        const labelText = label.textContent.replace(/\*/g, '');
        return labelText.trim();
      }
      
      return 'This field';
    }

    // Show an error message for a specific field
    function showFieldError(input, message) {
      const errorId = `${input.id}-error`;
      const errorElement = form.querySelector(`#${errorId}`);
      
      if (errorElement) {
        errorElement.textContent = message;
        errorElement.hidden = false;
      }
      
      // Mark the input as invalid for screen readers
      input.setAttribute('aria-invalid', 'true');
      input.classList.add('form-input-invalid');
    }

    // Clear the error message for a field (when user starts typing)
    function clearFieldError(input) {
      const errorId = `${input.id}-error`;
      const errorElement = form.querySelector(`#${errorId}`);
      
      if (errorElement) {
        errorElement.textContent = '';
        errorElement.hidden = true;
      }
      
      // Remove the invalid state
      input.setAttribute('aria-invalid', 'false');
      input.classList.remove('form-input-invalid');
    }

    // Handle form submission
    form.addEventListener('submit', function(e) {
      e.preventDefault();

      // Check if the form has a valid action URL
      if (!form.action || form.action === '/' || form.action.trim() === '') {
        if (errorMessage) {
          errorMessage.textContent = 'Form endpoint is not configured. Please contact the administrator.';
          errorMessage.hidden = false;
          errorMessage.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
        return;
      }

      // Hide any previous messages
      if (successMessage) {
        successMessage.hidden = true;
      }
      if (errorMessage) {
        errorMessage.hidden = true;
      }

      // Clear all previous field errors
      const allFields = form.querySelectorAll('input, textarea');
      for (let i = 0; i < allFields.length; i++) {
        clearFieldError(allFields[i]);
      }

      // Get all the form data
      const formData = new FormData(form);

      // Validate all required fields
      const requiredFields = form.querySelectorAll('[required]');
      let isValid = true;
      let firstInvalidField = null;

      for (let j = 0; j < requiredFields.length; j++) {
        const input = requiredFields[j];
        const value = input.value ? input.value.trim() : '';
        const fieldLabel = getFieldLabel(input);

        // Check if required field is empty
        if (!value) {
          isValid = false;
          showFieldError(input, `Please enter your ${fieldLabel.toLowerCase()}`);
          
          // Remember the first invalid field so we can focus on it
          if (!firstInvalidField) {
            firstInvalidField = input;
          }
          continue;
        }

        // If it's an email field, validate the email format
        if (input.type === 'email' && value) {
          const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
          if (!emailRegex.test(value)) {
            isValid = false;
            showFieldError(input, 'Please enter a valid email address');
            
            if (!firstInvalidField) {
              firstInvalidField = input;
            }
            continue;
          }
        }
      }

      // If validation failed, focus on the first invalid field and stop
      if (!isValid) {
        if (firstInvalidField) {
          firstInvalidField.focus();
          firstInvalidField.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
        return;
      }

      // Disable the submit button and show loading state
      if (submitButton) {
        submitButton.disabled = true;
        submitButton.textContent = 'Submitting...';
      }

      // Send the form data to the server
      fetch(form.action, {
        method: form.method,
        body: formData
      })
      .then(function(response) {
        if (response.ok) {
          if (successMessage) {
            successMessage.hidden = false;
            form.reset();
            successMessage.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
          }
        } else {
          if (errorMessage) {
            errorMessage.hidden = false;
            errorMessage.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
          }
        }
      })
      .catch(function() {
        if (errorMessage) {
          errorMessage.hidden = false;
          errorMessage.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
      })
      .finally(function() {
        if (submitButton) {
          submitButton.disabled = false;
          submitButton.textContent = originalButtonText;
        }
      });
    });

    // Clear field errors when user starts typing in a field that has an error
    const allInputs = form.querySelectorAll('input, textarea');
    for (let k = 0; k < allInputs.length; k++) {
      const input = allInputs[k];
      input.addEventListener('input', function() {
        const hasError = this.getAttribute('aria-invalid') === 'true';
        if (hasError) {
          clearFieldError(this);
        }
      });
    }
  }

 
  function initAllForms() {
    const forms = document.querySelectorAll('form[data-formbold-form]');
    
    for (let i = 0; i < forms.length; i++) {
      initForm(forms[i]);
    }
  }

  // Wait for the page to load before initializing forms
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initAllForms);
  } else {
    initAllForms();
  }
})();
</script>

