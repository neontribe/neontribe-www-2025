---
export interface Props {
  action?: string;
  method?: 'get' | 'post';
  title?: string;
  description?: string;
  class?: string;
  formId?: string;
  successMessage?: string;
  errorMessage?: string;
}

const {
  action = '/',
  method = 'post',
  title,
  description,
  class: className = '',
  formId,
  successMessage = 'Thank you! Your message has been sent successfully.',
  errorMessage = 'Sorry, there was an error submitting your form. Please try again.',
} = Astro.props;

const uniqueFormId = formId || `form-${Math.random().toString(36).substring(2, 11)}`;
---

<form 
  id={uniqueFormId}
  action={action} 
  method={method}
  class={`form ${className}`}
  novalidate
  data-formbold-form
  data-form-id={uniqueFormId}
>
  {title && (
    <h2 class="form-title">{title}</h2>
  )}
  {description && (
    <p class="form-description">{description}</p>
  )}
  
  <!-- Success message (hidden by default) -->
  <div 
    class="form-message form-message-success" 
    role="alert" 
    aria-live="polite"
    hidden
  >
    <p>{successMessage}</p>
  </div>
  
  <!-- Error message (hidden by default) -->
  <div 
    class="form-message form-message-error" 
    role="alert" 
    aria-live="assertive"
    hidden
  >
    <p>{errorMessage}</p>
  </div>
  
  <div class="form-fields">
    <slot />
  </div>
</form>

<script>
  (function() {
    // Use data attribute to find form to avoid issues with formId variable injection
    // Find the form that contains the submit button when clicked
    const forms = document.querySelectorAll('form[data-formbold-form]');
    if (forms.length === 0) return;
    
    // For now, just use the first form found
    // In practice, each form will have its own script instance
    const formElement = forms[0];
    const form = formElement as HTMLFormElement;
    
    const successMessage = form.querySelector('.form-message-success') as HTMLElement | null;
    const errorMessage = form.querySelector('.form-message-error') as HTMLElement | null;
    const submitButton = form.querySelector('button[type="submit"]') as HTMLButtonElement | null;
    const originalButtonText = submitButton?.textContent || 'Submit';
    
    // Helper function to get field label text for error messages
    // Removes asterisk (*) and trims whitespace
    function getFieldLabel(input: HTMLInputElement | HTMLTextAreaElement): string {
      const id = input.id;
      if (!id) return 'This field';
      const label = form.querySelector(`label[for="${id}"]`);
      if (label) {
        return label.textContent.replace(/\*/g, '').trim();
      }
      return 'This field';
    }

    // Helper function to show inline error
    function showFieldError(input: HTMLInputElement | HTMLTextAreaElement, message: string) {
      const errorId = `${input.id}-error`;
      const errorElement = form.querySelector(`#${errorId}`) as HTMLElement | null;
      if (errorElement) {
        errorElement.textContent = message;
        errorElement.hidden = false;
      }
      input.setAttribute('aria-invalid', 'true');
      input.classList.add('form-input-invalid');
    }

    // Helper function to clear field error
    function clearFieldError(input: HTMLInputElement | HTMLTextAreaElement) {
      const errorId = `${input.id}-error`;
      const errorElement = form.querySelector(`#${errorId}`) as HTMLElement | null;
      if (errorElement) {
        errorElement.textContent = '';
        errorElement.hidden = true;
      }
      input.setAttribute('aria-invalid', 'false');
      input.classList.remove('form-input-invalid');
    }

    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      
      // Hide previous messages
      if (successMessage) successMessage.hidden = true;
      if (errorMessage) errorMessage.hidden = true;
      
      // Clear all field errors
      const allFields = form.querySelectorAll('input, textarea') as NodeListOf<HTMLInputElement | HTMLTextAreaElement>;
      allFields.forEach((field) => {
        clearFieldError(field);
      });
      
      // Validate form before submission
      const formData = new FormData(form);
      const requiredFields = form.querySelectorAll('[required]') as NodeListOf<HTMLInputElement | HTMLTextAreaElement>;
      let isValid = true;
      let firstInvalidField: HTMLInputElement | HTMLTextAreaElement | null = null;
      
      // Check required fields
      requiredFields.forEach((field) => {
        const input = field as HTMLInputElement | HTMLTextAreaElement;
        const value = input.value.trim();
        const fieldLabel = getFieldLabel(input);
        
        // Check if required field is empty
        if (!value) {
          isValid = false;
          showFieldError(input, `Please enter your ${fieldLabel.toLowerCase()}`);
          if (!firstInvalidField) {
            firstInvalidField = input;
          }
          return;
        }
        
        // Validate email format
        if ('type' in input && input.type === 'email' && value) {
          const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
          if (!emailRegex.test(value)) {
            isValid = false;
            showFieldError(input, 'Please enter a valid email address');
            if (!firstInvalidField) {
              firstInvalidField = input;
            }
            return;
          }
        }
      });
      
      // If validation fails, focus first invalid field
      if (!isValid) {
        if (firstInvalidField) {
          firstInvalidField.focus();
          firstInvalidField.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
        return;
      }
      
      if (submitButton) {
        /** @type {HTMLButtonElement} */ (submitButton).disabled = true;
        submitButton.textContent = 'Submitting...';
      }
      
      try {
        const formAction = form.action;
        const formMethod = form.method;
        const response = await fetch(formAction, {
          method: formMethod,
          body: formData,
        });
        
        // FormBold returns 200 status on successful submission
        if (response.ok) {
          if (successMessage) {
            successMessage.hidden = false;
            form.reset();
            successMessage.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
          }
        } else {
          try {
            await response.json();
          } catch {
            // Ignore JSON parse errors
          }
          
          if (errorMessage) {
            errorMessage.hidden = false;
            errorMessage.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
          }
        }
      } catch (error) {
        if (errorMessage) {
          errorMessage.hidden = false;
          errorMessage.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
      } finally {
        if (submitButton) {
          submitButton.disabled = false;
          submitButton.textContent = originalButtonText;
        }
      }
    });

    // Clear field errors when user starts typing
    const allInputs = form.querySelectorAll('input, textarea') as NodeListOf<HTMLInputElement | HTMLTextAreaElement>;
    allInputs.forEach((input) => {
      input.addEventListener('input', () => {
        if (input.getAttribute('aria-invalid') === 'true') {
          clearFieldError(input);
        }
      });
    });
  })();
</script>

